---
title: "系统调用"
date: 2020-09-21T20:21:55+08:00
tags: ["系统调用", "内核栈", "操作系统"] 
draft: false
notoc: false
---

没有特别说明: 
 1. 举例默认为linux 系统. 
 1. 注重逻辑上描述, 忽略一些细节. 

## 什么是系统调用

 1. 操作系统为用户态进程和硬件设备进行交互提供了一组接口

优点
 1. 更简单. 隔离了具体硬件的细节, 不用对着硬件说明书编程. 
 1. 可移植. 

## 和函数调用的区别

 1. 从编程角度看, 很像. 都是传参和返回. 
 1. 从实现上看, 区别非常大. 函数调用发生在用户态, 系统调用会发生用户态和内核态的切换. 
    1. 函数调用设置ip寄存器为被调用的函数
    1. 系统调用调用 0x80 号中断

小知识: CPU的工作原理. CPU不仅看ip寄存器取下一条指令执行; CPU还会看是否有中断发生, 如果有中断请求, 会优先处理中断. 

## 系统调用的实现和过程

系统调用的发生

```
调用 int 0x80 汇编指令
调用的系统调用编号 ax
参数通过 di, si, dx, r10, r8, r9 传递
```

逻辑上理解
 1. 调用int 0x80 汇编指令, 
 1. 先把调用的执行环境保存起来: CPU寄存器的值. 
 1. 执行具体的系统调用的代码
 1. 将放回值放入 eax, 返回
 1. 调用者从 eax 读取到系统调用的返回值

## 栈

一个线程用两个栈: 用户栈, 内核栈. 我们一般讨论堆和栈时, 都是说的用户栈, 我们写的业务逻辑的代码一般都是运行在用户态, 用户栈是我们编程可以控制的. 当线程运行在内核态时, 使用的是内核栈, 由内核操作使用. 

函数调用: 在原来线程的用户栈上增加一层栈帧

系统调用: 实现在内核态. 用到的是内核栈. 内核栈说明
 1. 每个线程都有自己的内核栈
 1. 在系统调用发生前, 内核栈为空
 1. 在系统调用完成后, 内核栈数据失效, 也认为空
 1. 系统调用实现也有调用的话, 是在内核栈上增加一层栈帧
